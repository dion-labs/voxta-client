{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Voxta Python Client","text":"<p>A core library for interacting with the Voxta conversational AI platform using Python. This client enables real-time communication with Voxta characters using the SignalR protocol.</p>"},{"location":"#quick-install","title":"Quick Install","text":"<pre><code>pip install voxta-client\n</code></pre>"},{"location":"#protocol-support","title":"Protocol Support","text":"Category Feature Status Core Authentication, App Registration, Chat Subscription \u2705 Supported Messaging Start Chat, Resume Chat, Send Message, Speech Requests \u2705 Supported Control Interrupt, Pause, Inspect Session \u2705 Supported Context Update Context, Actions/Events, Role Management \u2705 Supported Media Playback Sync \u2705 Supported Media Audio Streaming (PCM), Vision / Images \u274c Not Planned <p>Get Started</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to the Voxta Python Client!</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>This project uses uv for dependency management and Ruff for linting and formatting.</p>"},{"location":"contributing/#1-clone-the-repository","title":"1. Clone the repository","text":"<pre><code>git clone https://github.com/dion-labs/voxta-client.git\ncd voxta-client\n</code></pre>"},{"location":"contributing/#2-install-dependencies","title":"2. Install dependencies","text":"<pre><code>uv sync --all-extras\n</code></pre>"},{"location":"contributing/#3-install-pre-commit-hooks","title":"3. Install pre-commit hooks","text":"<pre><code>uv run pre-commit install\n</code></pre>"},{"location":"contributing/#4-run-tests","title":"4. Run tests","text":"<pre><code>uv run pytest\n</code></pre>"},{"location":"contributing/#5-build-documentation-locally","title":"5. Build documentation locally","text":"<pre><code>uv run mkdocs serve\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create a new branch for your changes.</li> <li>Ensure tests pass and the code is properly formatted (<code>ruff format .</code>).</li> <li>Submit a pull request with a clear description of your changes.</li> </ol>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install the Voxta Python Client directly from PyPI:</p> <pre><code>pip install voxta-client\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>The following example shows how to connect to a local Voxta server and send a simple message.</p> <pre><code>import asyncio\nfrom voxta_client import VoxtaClient\n\nasync def main():\n    # 1. Initialize the client\n    client = VoxtaClient(\"http://localhost:5384\")\n\n    # Set up event listeners\n    @client.on(\"message\")\n    async def on_message(payload):\n        if payload.get(\"senderType\") == \"Character\":\n            print(f\"\\nCharacter: {payload.get('text')}\")\n\n    # 2. Negotiate connection\n    print(\"Negotiating connection...\")\n    token, cookies = client.negotiate()\n\n    # 3. Connect (runs the message loop in the background)\n    connection_task = asyncio.create_task(client.connect(token, cookies))\n\n    # Wait for the client to be ready (connected and session pinned)\n    ready_event = asyncio.Event()\n    client.on(\"ready\", lambda _: ready_event.set())\n\n    print(\"Connecting to Voxta...\")\n    await ready_event.wait()\n    print(f\"Connected! Session ID: {client.session_id}\")\n\n    # 4. Send a message\n    print(\"Sending message...\")\n    await client.send_message(\"Hello! Tell me a short story.\")\n\n    # Wait for response\n    await asyncio.sleep(10)\n\n    # Clean up\n    await client.close()\n    await connection_task\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#advanced-configuration","title":"Advanced Configuration","text":"<p>For more complex scenarios, such as updating context or handling specific SignalR events, please refer to the API Reference.</p>"},{"location":"api/client/","title":"VoxtaClient API","text":""},{"location":"api/client/#voxta_client.client.VoxtaClient","title":"<code>voxta_client.client.VoxtaClient</code>","text":"<p>High-level client for interacting with the Voxta conversational AI platform.</p> Source code in <code>voxta_client/client.py</code> <pre><code>class VoxtaClient:\n    \"\"\"\n    High-level client for interacting with the Voxta conversational AI platform.\n    \"\"\"\n\n    def __init__(self, url: str):\n        self.url = url\n        self.logger = logging.getLogger(\"VoxtaClient\")\n        self.transport = VoxtaTransport(url, logger=self.logger.getChild(\"Transport\"))\n        self.transport.set_callbacks(\n            on_message=self._handle_server_message, on_close=self._handle_close\n        )\n\n        self.callbacks: dict[str, list[Callable]] = {}\n        self.session_id: Optional[str] = None\n        self.chat_id: Optional[str] = None\n        self.assistant_id: Optional[str] = None\n        self.is_speaking = False\n        self.is_thinking = False\n        self.last_message_id: Optional[str] = None\n        self._active_chat_id: Optional[str] = None\n\n    @property\n    def running(self) -&gt; bool:\n        return self.transport.running\n\n    def on(self, event_name: str, callback: Optional[Callable] = None) -&gt; Any:\n        \"\"\"\n        Register a callback for a specific event. Can be used as a decorator.\n        \"\"\"\n        if callback is not None:\n            if event_name not in self.callbacks:\n                self.callbacks[event_name] = []\n            self.callbacks[event_name].append(callback)\n            return callback\n\n        def decorator(inner_callback: Callable):\n            if event_name not in self.callbacks:\n                self.callbacks[event_name] = []\n            self.callbacks[event_name].append(inner_callback)\n            return inner_callback\n\n        return decorator\n\n    def negotiate(self):\n        return self.transport.negotiate()\n\n    async def connect(self, connection_token: str, cookies: Optional[dict[str, str]] = None):\n        await self.transport.connect(connection_token, cookies)\n        await self.authenticate(connection_token)\n\n    async def _send_client_message(self, message: ClientMessage):\n        invocation_id = str(uuid.uuid4())\n        await self.transport.send(message.to_signalr_invocation(invocation_id))\n\n    async def authenticate(self, _token: str):\n        self.logger.info(\"Authenticating...\")\n        await self._send_client_message(ClientAuthenticateMessage())\n\n    async def register_app(self, label: str = \"Voxta Python Client\"):\n        self.logger.info(f\"Registering app: {label}\")\n        await self._send_client_message(\n            ClientRegisterAppMessage(clientVersion=\"1.2.1\", label=label)\n        )\n\n    async def start_chat(self, character_id: str, contexts: Optional[list[dict[str, Any]]] = None):\n        invocation_id = str(uuid.uuid4())\n        payload = {\n            \"type\": 1,\n            \"invocationId\": invocation_id,\n            \"target\": \"SendMessage\",\n            \"arguments\": [\n                {\"$type\": \"startChat\", \"characterId\": character_id, \"contexts\": contexts or []}\n            ],\n        }\n        self.logger.info(f\"Starting chat with character: {character_id}\")\n        await self.transport.send(payload)\n\n    async def resume_chat(self, chat_id: str):\n        invocation_id = str(uuid.uuid4())\n        payload = {\n            \"type\": 1,\n            \"invocationId\": invocation_id,\n            \"target\": \"SendMessage\",\n            \"arguments\": [{\"$type\": \"resumeChat\", \"chatId\": chat_id}],\n        }\n        self.logger.info(f\"Resuming chat: {chat_id}\")\n        await self.transport.send(payload)\n\n    async def subscribe_to_chat(self, session_id: str, chat_id: str):\n        invocation_id = str(uuid.uuid4())\n        payload = {\n            \"type\": 1,\n            \"invocationId\": invocation_id,\n            \"target\": \"SendMessage\",\n            \"arguments\": [{\"$type\": \"subscribeToChat\", \"sessionId\": session_id, \"chatId\": chat_id}],\n        }\n        self.logger.info(f\"Subscribing to chat: {chat_id}\")\n        await self.transport.send(payload)\n\n    async def send_message(\n        self,\n        text: str,\n        session_id: Optional[str] = None,\n        do_reply: bool = True,\n        do_user_inference: bool = True,\n        do_character_inference: bool = True,\n    ):\n        target_session = session_id or self.session_id\n        if not target_session:\n            self.logger.error(\"No session ID available to send message\")\n            return\n\n        msg = ClientSendMessage(\n            sessionId=target_session,\n            text=text,\n            doReply=do_reply,\n            doUserActionInference=do_user_inference,\n            doCharacterActionInference=do_character_inference,\n        )\n        self.logger.info(f\"Sending message to session {target_session}: {text[:50]}...\")\n        await self._send_client_message(msg)\n\n    async def interrupt(self, session_id: Optional[str] = None):\n        target_session = session_id or self.session_id\n        if not target_session:\n            return\n        invocation_id = str(uuid.uuid4())\n        payload = {\n            \"type\": 1,\n            \"invocationId\": invocation_id,\n            \"target\": \"SendMessage\",\n            \"arguments\": [{\"$type\": \"interrupt\", \"sessionId\": target_session}],\n        }\n        await self.transport.send(payload)\n\n    async def pause(self, session_id: Optional[str] = None):\n        target_session = session_id or self.session_id\n        if not target_session:\n            return\n        invocation_id = str(uuid.uuid4())\n        payload = {\n            \"type\": 1,\n            \"invocationId\": invocation_id,\n            \"target\": \"SendMessage\",\n            \"arguments\": [{\"$type\": \"pause\", \"sessionId\": target_session}],\n        }\n        await self.transport.send(payload)\n\n    async def update_context(\n        self,\n        session_id: str,\n        context_key: str,\n        contexts: Optional[list[dict[str, Any]]] = None,\n        actions: Optional[list[dict[str, Any]]] = None,\n        events: Optional[list[dict[str, Any]]] = None,\n        set_flags: Optional[list[str]] = None,\n        enable_roles: Optional[dict[str, bool]] = None,\n    ):\n        msg = ClientUpdateContextMessage(\n            sessionId=session_id,\n            contextKey=context_key,\n            contexts=contexts,\n            actions=actions,\n            events=events,\n            setFlags=set_flags,\n            enableRoles=enable_roles,\n        )\n        await self._send_client_message(msg)\n\n    async def _handle_server_message(self, message: dict[str, Any]):\n        msg_type = message.get(\"type\")\n        if msg_type == 6:  # Ping\n            return\n        if msg_type == 7:  # Close\n            self.logger.warning(\"SignalR Close message received\")\n            self.transport.running = False\n            return\n        if msg_type == 3:  # Completion\n            if message.get(\"error\"):\n                self.logger.error(f\"Invocation failed: {message.get('error')}\")\n            return\n\n        if msg_type == 1:  # Invocation\n            target = message.get(\"target\")\n            if target == \"ReceiveMessage\":\n                args = message.get(\"arguments\", [])\n                if args:\n                    payload = args[0]\n                    await self._process_voxta_event(payload)\n\n    async def _process_voxta_event(self, payload: dict[str, Any]):\n        event_type = payload.get(\"$type\")\n        if not event_type:\n            return\n\n        # Track message IDs\n        msg_id = payload.get(\"messageId\") or payload.get(\"id\")\n        if msg_id and event_type in [\n            EventType.MESSAGE,\n            EventType.UPDATE,\n            EventType.REPLY_START,\n            EventType.SPEECH_PLAYBACK_START,\n        ]:\n            self.last_message_id = msg_id\n\n        # Logging\n        if event_type in [EventType.MESSAGE, EventType.UPDATE]:\n            sender = payload.get(\"senderType\") or payload.get(\"role\")\n            text = payload.get(\"text\", \"\")[:100]\n            self.logger.info(f\"Voxta Event: {event_type} | From {sender}: {text}...\")\n        else:\n            self.logger.info(f\"Voxta Event: {event_type}\")\n\n        # Internal state management\n        if event_type == EventType.WELCOME:\n            self.assistant_id = payload.get(\"assistant\", {}).get(\"id\")\n            await self.register_app()\n        elif event_type == EventType.CHATS_SESSIONS_UPDATED:\n            await self._handle_sessions_updated(payload)\n        elif event_type == EventType.CHAT_STARTED:\n            await self._handle_chat_started(payload)\n        elif event_type == EventType.ERROR:\n            err_msg = payload.get(\"message\", \"\")\n            if \"Chat session already exists\" in err_msg:\n                self.logger.info(\n                    \"Ignoring 'Chat session already exists' error \"\n                    \"(this is normal during proxy resumption).\"\n                )\n            else:\n                self.logger.error(f\"Voxta Error: {err_msg}\")\n        elif event_type in [EventType.REPLY_GENERATING, EventType.REPLY_START]:\n            self.is_thinking = True\n        elif event_type == EventType.REPLY_END:\n            self.is_thinking = False\n        elif event_type == EventType.SPEECH_PLAYBACK_START:\n            self.is_speaking = True\n        elif event_type in [EventType.SPEECH_PLAYBACK_COMPLETE, EventType.INTERRUPT_SPEECH]:\n            self.is_speaking = False\n            if event_type == EventType.INTERRUPT_SPEECH:\n                self.is_thinking = False\n\n        # Emit event\n        await self._emit(event_type, payload)\n\n    async def _handle_sessions_updated(self, payload: dict[str, Any]):\n        sessions = payload.get(\"sessions\", [])\n        if sessions and not self.chat_id:\n            target = next(\n                (s for s in sessions if s.get(\"chatId\") == self._active_chat_id),\n                sessions[0],\n            )\n            self.chat_id = target.get(\"chatId\")\n            self._active_chat_id = self.chat_id\n            if not self.session_id:\n                self.session_id = target.get(\"sessionId\")\n            self.logger.info(f\"Pinned to Chat: {self.chat_id}\")\n            await self.subscribe_to_chat(self.session_id, self.chat_id)\n            await self._emit(EventType.READY, self.session_id)\n\n    async def _handle_chat_started(self, payload: dict[str, Any]):\n        new_session_id = payload.get(\"sessionId\")\n        new_chat_id = payload.get(\"chatId\")\n        if new_chat_id and new_chat_id != self._active_chat_id:\n            self.session_id = new_session_id\n            self.chat_id = new_chat_id\n            self._active_chat_id = new_chat_id\n            await self._emit(EventType.READY, self.session_id)\n\n    async def _emit(self, event_name: str, data: Any):\n        if event_name in self.callbacks:\n            for cb in self.callbacks[event_name]:\n                try:\n                    if asyncio.iscoroutinefunction(cb):\n                        await cb(data)\n                    else:\n                        cb(data)\n                except Exception as e:\n                    self.logger.error(f\"Error in callback for {event_name}: {e}\")\n\n    def _handle_close(self):\n        self.logger.info(\"Connection closed\")\n        asyncio.create_task(self._emit(\"close\", None))\n\n    async def close(self):\n        \"\"\"\n        Close the client connection.\n        \"\"\"\n        await self.transport.close()\n</code></pre>"},{"location":"api/client/#voxta_client.client.VoxtaClient-functions","title":"Functions","text":""},{"location":"api/client/#voxta_client.client.VoxtaClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the client connection.</p> Source code in <code>voxta_client/client.py</code> <pre><code>async def close(self):\n    \"\"\"\n    Close the client connection.\n    \"\"\"\n    await self.transport.close()\n</code></pre>"},{"location":"api/client/#voxta_client.client.VoxtaClient.on","title":"<code>on(event_name, callback=None)</code>","text":"<p>Register a callback for a specific event. Can be used as a decorator.</p> Source code in <code>voxta_client/client.py</code> <pre><code>def on(self, event_name: str, callback: Optional[Callable] = None) -&gt; Any:\n    \"\"\"\n    Register a callback for a specific event. Can be used as a decorator.\n    \"\"\"\n    if callback is not None:\n        if event_name not in self.callbacks:\n            self.callbacks[event_name] = []\n        self.callbacks[event_name].append(callback)\n        return callback\n\n    def decorator(inner_callback: Callable):\n        if event_name not in self.callbacks:\n            self.callbacks[event_name] = []\n        self.callbacks[event_name].append(inner_callback)\n        return inner_callback\n\n    return decorator\n</code></pre>"},{"location":"api/constants/","title":"Constants","text":"<p>Common event types and service types used in the Voxta ecosystem.</p>"},{"location":"api/constants/#voxta_client.constants","title":"<code>voxta_client.constants</code>","text":""},{"location":"api/models/","title":"Models","text":"<p>These classes define the data structures for SignalR messages exchanged between the client and the Voxta server.</p>"},{"location":"api/models/#voxta_client.models","title":"<code>voxta_client.models</code>","text":""},{"location":"api/models/#voxta_client.models-classes","title":"Classes","text":""},{"location":"api/models/#voxta_client.models.ClientMessage","title":"<code>ClientMessage</code>  <code>dataclass</code>","text":"<p>               Bases: <code>VoxtaModel</code></p> <p>Base class for all messages to the server.</p> Source code in <code>voxta_client/models.py</code> <pre><code>@dataclass\nclass ClientMessage(VoxtaModel):\n    \"\"\"Base class for all messages to the server.\"\"\"\n\n    def to_signalr_invocation(self, invocation_id: str) -&gt; dict[str, Any]:\n        return {\n            \"type\": 1,\n            \"invocationId\": invocation_id,\n            \"target\": \"SendMessage\",\n            \"arguments\": [self.to_dict()],\n        }\n</code></pre>"},{"location":"api/models/#voxta_client.models.ServerMessage","title":"<code>ServerMessage</code>  <code>dataclass</code>","text":"<p>               Bases: <code>VoxtaModel</code></p> <p>Base class for all messages from the server.</p> Source code in <code>voxta_client/models.py</code> <pre><code>@dataclass\nclass ServerMessage(VoxtaModel):\n    \"\"\"Base class for all messages from the server.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/models/#voxta_client.models.VoxtaModel","title":"<code>VoxtaModel</code>  <code>dataclass</code>","text":"<p>Base class for Voxta data models.</p> Source code in <code>voxta_client/models.py</code> <pre><code>@dataclass\nclass VoxtaModel:\n    \"\"\"Base class for Voxta data models.\"\"\"\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        data = {k: v for k, v in self.__dict__.items() if v is not None}\n        # Map internal names to SignalR/Voxta names\n        if \"type_name\" in data:\n            data[\"$type\"] = data.pop(\"type_name\")\n        return data\n</code></pre>"}]}